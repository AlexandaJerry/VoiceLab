import math
import numpy as np
import statistics

from Voicelab.pipeline.Node import Node
from parselmouth.praat import call
from Voicelab.toolkits.Voicelab.VoicelabNode import VoicelabNode


# TEVA NODE
# WARIO pipeline node for manipulating the pitch of a voice.
# ARGUMENTS
# 'voice'   : sound file generated by parselmouth praat
# RETURNS


class TEVANode(VoicelabNode):
    def __init__(self, *args, **kwargs):
        """
        Args:
            *args:
            **kwargs:
        """
        super().__init__(*args, **kwargs)

        self.args = {
            "pitch_ceiling": ("250", ["250", "300", "600"]),
            "start_time": 0,  # Positive number or 0
            "end_time": 0,  # Positive number or 0
            "shortest_period": 0.0001,  # Positive number
            "longest_period": 0.05,  # Positive number
            "max_period_factor": 5,  # Positive integer
            "maximum_amplitude": 5,  # Positive integer
            "time step": 0.0025,  # Positive number
            "max number of formants": 5,  # Positive integer
            "window length(s)": 0.025,  # Positive number
            "pre emphasis from": 50,  # Positive number
            "max_formant": 5500,  # Positive number
        }

        # %%
        self.pitch = None
        self.mean_f0_teva = None
        self.stdev_f0_teva = None
        self.median_f0_teva = None
        self.voiced_frames = None
        self.number_of_frames = None
        self.voiced_fraction = None
        self.point_process = None
        self.local_jitter_teva = None
        self.local_shimmer_teva = None
        self.harmonicity = None
        self.matrix = None
        self.matrix_sound = None
        self.filtered_matrix_sound = None
        self.time_of_maximum = None
        self.hnr_teva = None
        self.time_step = None
        self.duration = None
        self.filtered_sound = None
        self.harmonicity_low = None
        self.hnr_teva_low = None
        self.harmonicity_high = None
        self.hnr_teva_high = None
        self.window_size = None
        self.gne = None
        self.gne_sound = None
        self.start_sample = None
        self.end_sample = None
        self.cog_teva = None
        self.low_power = None
        self.start_bin = None
        self.end_bin = None
        self.power = None
        self.bed = None
        self.textgrid = None
        self.qf1 = None
        self.qf2 = None
        self.qf3 = None
        self.qf4 = None
        self.spectrum = None
        self.ltas = None
        self.number_of_bins = None
        self.sum_power = None
        self.product_frequency = None
        self.t1 = None
        self.t2 = None
        self.frame = None
        self.gne_sound = None
        self.gne_id = None
        self.gne_value = None
        self.frequency = None
        self.energy = None
        self.high_power = None
        self.mvd = None
        self.ast_score = None
        # %%

        # process: WARIO hook called once for each voice file.
        # %%





    def process(self):
        try:
            self.sound = self.args["voice"]
            self.start_time = 0
            self.end_time = 0
            self.pitch_ceiling = float(self.args['pitch_ceiling'][0])
            self.shortest_period = self.args["shortest_period"]
            self.longest_period = self.args["longest_period"]
            self.maximum_period_factor = self.args["max_period_factor"]
            self.max_period_factor = self.args["max_period_factor"]
            self.maximum_amplitude = self.args["maximum_amplitude"]
            self.time_step = self.args["time step"]
            self.max_number_of_formants = self.args["max number of formants"]
            self.window_length = self.args["window length(s)"]
            self.pre_emphasis_from = self.args["pre emphasis from"]
            self.max_formant = self.args["max_formant"]

            self.measure_voiced_fraction()
            self.measure_jitter()
            self.measure_shimmer()
            self.measure_hnr()
            self.measure_gne()
            self.measure_cog()
            self.measure_bed()
            self.measure_mvd()
            self.measure_qfi()
            self.categorize()

            return {
                "Mean Pitch": self.mean_f0_teva,
                "Standard Deviation Pitch": self.stdev_f0_teva,
                "Median Pitch": self.median_f0_teva,
                "Voiced Fraction": self.voiced_fraction,
                "HNR": self.hnr_teva,
                "HNR High": self.hnr_teva_high,
                "HNR Low": self.hnr_teva_low,
                "Jitter": self.local_jitter_teva,
                "Shimmer": self.local_shimmer_teva,
                "GNE (glottal to noise excitation ratio)": self.gne_id,
                "BED (band energy difference)": self.bed,
                "Center of gravity": self.cog_teva,
                "MVD Maximum Voicing Duration": self.mvd,
                "Formant quality (QF_1)": self.qf1,
                "Formant quality (QF_2)": self.qf2,
                "Formant quality (QF_3)": self.qf3,
                "Formant quality (QF_4)": self.qf4,
                "AST Score": self.ast_score,
            }
        except:
            return {
                "Mean Pitch": "TEVA failed",
                "Standard Deviation Pitch":  "TEVA failed",
                "Median Pitch":  "TEVA failed",
                "Voiced Fraction":  "TEVA failed",
                "HNR":  "TEVA failed",
                "HNR High": "TEVA failed",
                "HNR Low":  "TEVA failed",
                "Jitter":  "TEVA failed",
                "Shimmer":  "TEVA failed",
                "GNE (glottal to noise excitation ratio)":  "TEVA failed",
                "BED (band energy difference)":  "TEVA failed",
                "Center of gravity":  "TEVA failed",
                "MVD Maximum Voicing Duration":  "TEVA failed",
                "Formant quality (QF_1)":  "TEVA failed",
                "Formant quality (QF_2)":  "TEVA failed",
                "Formant quality (QF_3)":  "TEVA failed",
                "Formant quality (QF_4)":  "TEVA failed",
                "AST Score":  "TEVA failed",
            }

    def measure_voiced_fraction(self):
        self.pitch = self.sound.to_pitch_cc(pitch_floor=40, pitch_ceiling=self.pitch_ceiling)
        self.mean_f0_teva: float = call(self.pitch, "Get mean", 0, 0, "Hertz")
        self.stdev_f0_teva: float = call(
            self.pitch, "Get standard deviation", 0, 0, "Hertz"
        )  # get standard deviation
        self.median_f0_teva: float = call(self.pitch, "Get quantile", 0, 0, 0.5, "Hertz")

        self.voiced_frames = call(self.pitch, "Count voiced frames")
        self.number_of_frames = call(self.pitch, "Get number of frames")
        self.voiced_fraction = self.voiced_frames / self.number_of_frames

    def measure_jitter(self):
        self.point_process: object = call(
            self.sound, "To PointProcess (periodic, cc)", 60, 600
        )
        self.local_jitter_teva: float = call(
            self.point_process,
            "Get jitter (local)",
            self.start_time,
            self.end_time,
            self.shortest_period,
            self.longest_period,
            self.maximum_period_factor,
        )

    def measure_shimmer(self):
        self.local_shimmer_teva: float = call(
            [self.sound, self.point_process],
            "Get shimmer (local)",
            self.start_time,
            self.end_time,
            self.shortest_period,
            self.longest_period,
            self.maximum_period_factor,
            self.maximum_amplitude,
        )

    def measure_hnr(self):
        #  Harmonicity to Noise Value
        self.time_step = 0.1
        self.duration = call(self.sound, "Get total duration")
        self.harmonicity = self.sound.to_harmonicity_cc(self.time_step, 40, 0, 4.5)
        self.harmonicity.values.T[self.harmonicity.values.T < 0] = 0
        self.matrix = call(self.harmonicity, "To Matrix")
        self.matrix_sound = call(self.matrix, "To Sound (slice)", 1)
        self.filtered_matrix_sound = call(
            self.matrix_sound, "Filter (pass Hann band)", 0, 4, 4
        )
        self.time_of_maximum = call(
            self.filtered_matrix_sound, "Get time of maximum", 0, 0, "Parabolic"
        )
        self.hnr_teva = call(self.filtered_matrix_sound, "Get maximum", 0, 0, "Parabolic")

        # harmonicity_low
        self.time_step = 0.005
        self.duration = call(self.sound, "Get total duration")
        self.filtered_sound = call(self.sound, "Filter (pass Hann band)", 0, 700, 100)
        self.harmonicity_low = self.filtered_sound.to_harmonicity_cc(
            self.time_step, 40, 0, 1
        )
        self.harmonicity_low.values.T[self.harmonicity_low.values.T < 0] = 0
        self.hnr_teva_low = call(self.harmonicity_low, "Get maximum", 0, 0, "Parabolic")

        # harmonicity_high
        self.filtered_sound = call(
            self.sound, "Filter (pass Hann band)", 700, 2300, 100
        )
        self.harmonicity_high = self.filtered_sound.to_harmonicity_cc(
            self.time_step, 40, 0, 1
        )
        self.harmonicity_high.values.T[self.harmonicity_high.values.T < 0] = 0
        self.hnr_teva_high = call(self.harmonicity_high, "Get maximum", 0, 0, "Parabolic")

    def measure_gne(self):
        #  Calcluate GNE (glottal to noise excitation ratio)
        self.time_step = 0.01
        self.window_size = 0.250
        self.gne = self.sound.to_harmonicity_gne(500, 4500, 1000, 80)
        self.gne_sound = call(
            "Create Sound from formula", "GNE", 1, 0, self.duration, 100, "0"
        )
        self.start_sample = math.ceil((0 + self.window_size / 2) / self.time_step)
        self.end_sample = math.floor(
            (self.duration - self.window_size / 2) / self.time_step
        )

        for t, self.x in enumerate(range(self.start_sample, self.end_sample), 1):
            t1 = t * self.time_step - self.window_size / 2
            t2 = t1 + self.time_step + self.window_size
            self.frame = call(
                self.gne_sound,
                "Extract part",
                t1,
                t2,
                "rectangular",
                1,
                "yes",
            )
            self.gne_id = self.frame.to_harmonicity_gne(500, 4500, 1000, 80)
            self.gne_value = call(self.gne_id, "Get maximum")
            call(self.gne_sound, "Set value at sample number", 0, t, self.gne_value)
            self.gne = call(self.gne_sound, "Get maximum", 0, 0, "Sinc70")

    def measure_cog(self):
        self.spectrum = self.sound.to_spectrum()
        self.ltas = call(self.spectrum, "To Ltas (1-to-1)")
        self.number_of_bins = call(self.ltas, "Get number of bins")
        self.sum_power = 0
        self.product_frequency = 0

        for bin_number, value in enumerate(range(self.number_of_bins), 1):
            self.power = call(self.ltas, "Get value in bin", bin_number)
            self.frequency = call(
                self.ltas, "Get frequency from bin number", bin_number
            )
            self.energy = 10 ** (self.power / 10)
            self.product_frequency += self.frequency * self.energy
            self.sum_power += self.energy

        if self.sum_power > 0:
            self.cog_teva = self.product_frequency / self.sum_power
        else:
            self.cog_teva = 0

    def measure_bed(self):
        #  BED (band energy difference)
        #  low power
        self.low_power = 0
        self.start_bin = int(round(call(self.ltas, "Get bin number from frequency", 0)))
        self.end_bin = int(round(call(self.ltas, "Get bin number from frequency", 500)))
        for i, j in enumerate(range(self.start_bin, self.end_bin), 1):
            self.power = call(self.ltas, "Get value in bin", i)
            self.low_power += 10 ** (self.power / 10)
        self.low_power /= self.end_bin - self.start_bin + 1

        #  high power
        self.high_power = 0
        self.start_bin = int(round(call(self.ltas, "Get bin number from frequency", 4000)))
        self.end_bin = int(round(call(self.ltas, "Get bin number from frequency", 5000)))
        for i, j in enumerate(range(self.start_bin, self.end_bin), 1):
            self.power = call(self.ltas, "Get value in bin", i)
            self.high_power += 10 ** (self.power / 10)

        #  calculate bed
        if self.high_power > 0:
            self.bed = 10 * math.log10(self.low_power / self.high_power)
        else:
            self.bed = 0

    def measure_mvd(self):
        #  Maximum Voicing Duration (MVD)
        textgrid = call(self.point_process, "To TextGrid (vuv)", 0.2, 0.1)
        maximum_voicing_durations = []
        number_of_intervals = call(textgrid, "Get number of intervals", 1)
        for interval, number in enumerate(range(number_of_intervals), 1):
            label = call(textgrid, "Get label of interval", 1, interval)
            if "v" in label.lower():
                start = call(textgrid, "Get start point", 1, interval)
                end = call(textgrid, "Get end point", 1, interval)
                maximum_voicing_duration = end - start
                maximum_voicing_durations.append(maximum_voicing_duration)
        self.mvd = max(maximum_voicing_durations)

    def measure_qfi(self):
        #  Formant quality factors (QF_i)
        formant_object: object = self.sound.to_formant_burg(
            self.time_step,
            self.max_number_of_formants,
            self.max_formant,
            self.window_length,
            self.pre_emphasis_from,
        )
        f1_median: float = call(formant_object, "Get quantile", 1, 0, 0,"Hertz", 0.5)
        f2_median: float = call(formant_object, "Get quantile", 2, 0, 0,"Hertz", 0.5)
        f3_median: float = call(formant_object, "Get quantile", 3, 0, 0,"Hertz", 0.5)
        f4_median: float = call(formant_object, "Get quantile", 4, 0, 0,"Hertz", 0.5)

        b1_median = call(
            formant_object, "Get quantile of bandwidth", 1, 0, 0, "Hertz", 0.5
        )
        b2_median = call(
            formant_object, "Get quantile of bandwidth", 2, 0, 0, "Hertz", 0.5
        )
        b3_median = call(
            formant_object, "Get quantile of bandwidth", 3, 0, 0, "Hertz", 0.5
        )
        b4_median = call(
            formant_object, "Get quantile of bandwidth", 4, 0, 0, "Hertz", 0.5
        )

        self.qf1: float = f1_median / b1_median
        self.qf2: float = f2_median / b2_median
        self.qf3: float = f3_median / b3_median
        self.qf4: float = f4_median / b4_median

    def categorize(self):
        voiced_fraction_category = 1
        if self.voiced_fraction < 90.2:
            voiced_fraction_category = 2
        elif self.voiced_fraction < 77.45:
            voiced_fraction_category = 3
        elif self.voiced_fraction < 50:
            voiced_fraction_category = 4

        voice_pitch_category = 1
        if self.stdev_f0_teva < 3.360:
            voice_pitch_category = 2
        elif self.stdev_f0_teva < 7.495:
            voice_pitch_category = 3
        elif self.voiced_fraction < 50:
            voice_pitch_category = 4

        jitter_category = 1
        if self.local_jitter_teva < 5.3:
            jitter_category = 2
        elif self.local_jitter_teva < 4.050:
            jitter_category = 3
        elif self.voiced_fraction < 50:
            jitter_category = 4

        harmonicity_category = 1
        if self.hnr_teva < 7.195:
            harmonicity_category = 2
        elif self.hnr_teva < 4.050:
            harmonicity_category = 3
        elif self.hnr_teva < 1.925:
            harmonicity_category = 4

        gne_category = 1
        if self.gne < 0.820:
            gne_category = 2
        elif self.gne < 0.795:
            gne_category = 3
        elif self.gne < 0.745:
            gne_category = 4

        bed_category = 1
        if self.bed < 23.85:
            bed_category = 2
        elif self.bed < 19.95:
            bed_category = 3
        elif self.bed < 13.50:
            bed_category = 4

        categories = [
            voiced_fraction_category,
            voice_pitch_category,
            jitter_category,
            harmonicity_category,
            gne_category,
            bed_category,
        ]

        self.ast_score = statistics.median(categories)
