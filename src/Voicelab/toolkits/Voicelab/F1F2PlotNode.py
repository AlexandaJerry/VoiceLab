from Voicelab.pipeline.Node import Node
import parselmouth
from parselmouth.praat import call
from Voicelab.toolkits.Voicelab.VoicelabNode import VoicelabNode
from Voicelab.toolkits.Voicelab.MeasureFormantNode import MeasureFormantNode
from Voicelab.VoicelabWizard.VoicelabTab import VoicelabTab
from Voicelab.VoicelabWizard.F1F2PlotWindow import F1F2PlotWindow

from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *

import io
import pandas as pd
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from matplotlib.patches import Ellipse
import matplotlib.transforms as transforms

from numpy import random
from scipy.spatial import distance

import numpy as np
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from scipy import stats


###################################################################################################
# F1F2PlotNode
# WARIO pipeline node for estimating the vocal tract of a voice.
###################################################################################################
# ARGUMENTS
# 'voice'   : sound file generated by parselmouth praat
# 'state'   : saves formant data for each voice for processing in end method
###################################################################################################
# RETURNS   : an unnamed string to keep the pipeline running
#           : saves an image file to disk: 'f1f2.png
###################################################################################################


class F1F2PlotNode(VoicelabNode):
    def __init__(self, *args, **kwargs):
        """
        Args:
            *args:
            **kwargs:
        """
        super().__init__(*args, **kwargs)

        self.args = {
            "Vowel Marker": ("Vowels",
                             ["Vowels", "IPA Symbols", "None"]),
            "Comparison Data": ("Peterson & Barney 1952",
                                ["Peterson & Barney 1952", "None"]),
            "Scale": ('Bark',
                      ['Bark', 'Hz']),
            "Colour Map": ('inferno',
                           ['viridis', 'plasma', 'inferno', 'magma', 'cividis']),
            "Ellipses": ("My data", ["My data", "Peterson & Barney 1952 Data", "No ellipses"]
            )
        }

        self.state = {
            "f1 means": [],
            "f2 means": [],
            "f3 means": [],
            "f4 means": [],
        }

    def process(self):
        f1 = self.args["F1 Mean"]
        f2 = self.args["F2 Mean"]
        f3 = self.args["F3 Mean"]
        f4 = self.args["F4 Mean"]

        self.state["f1 means"].append(f1)
        self.state["f2 means"].append(f2)
        self.state["f3 means"].append(f3)
        self.state["f4 means"].append(f4)

        f1_means = self.state["f1 means"]
        f2_means = self.state["f2 means"]
        f3_means = self.state["f3 means"]
        f4_means = self.state["f4 means"]

        return {
        }

    def closest_node(self, point, points):
        closest_index = distance.cdist([point], points).argmin()
        return points[closest_index], closest_index

    def end(self, results):
        # Fix menu options
        vowel_marker = self.args["Vowel Marker"][0]
        colour_map = self.args['Colour Map'][0]
        scale = self.args['Scale'][0]
        should_we_draw_ellipses = self.args['Ellipses'][0].lower()


        if vowel_marker == 'I':
            vowel_marker = "IPA Symbols"
        elif vowel_marker == 'V':
            vowel_marker = "Vowels"
        elif vowel_marker == "N":
            vowel_marker = "None"

        if colour_map == 'v':
            cmap = 'viridis'
        elif colour_map == 'p':
            cmap = 'plasma'
        elif colour_map == 'i':
            cmap = 'inferno'
        elif colour_map == 'm':
            cmap = 'magma'
        elif colour_map == 'c':
            cmap = 'cividis'
        else:
            cmap = colour_map

        # create the plot
        fig, ax_kwargs = plt.subplots()
        ax_kwargs.axvline(c='grey', lw=1)
        ax_kwargs.axhline(c='grey', lw=1)

        # Get the Peterson-Barney data
        df = gather_data()

        # Get IPA symbols
        ipa_conversion_dataframe = pd.read_csv('Voicelab/toolkits/Voicelab/IPA_Praat_symbols.csv', header=0)
        df = pd.merge(df, ipa_conversion_dataframe, how="inner", on='IPA')
        # Make a list of unique IPA symbols from the csv file
        ipa_symbols = list(df['Symbol'].unique())

        # Make a list of unique vowels in Peterson & Barney
        vowels = list(set(df["Vowel"]))

        # Use the list of vowels to specify a colour map for ellipses
        if vowel_marker == 'Vowels' or vowel_marker == 'None':
            colours = cm.get_cmap(cmap)(np.linspace(0, 1, len(vowels)))
        elif vowel_marker == 'IPA Symbols':
            colours = cm.get_cmap(cmap)(np.linspace(0, 1, len(ipa_symbols)))

        # Create a dataframe of formants from user
        # we will match these values to Peterson & Barney
        # to create ellipses based on user data
        user_data = pd.DataFrame(
            {
                "F1": self.state['f1 means'],
                "F2": self.state['f2 means'],
            }
        )
        if scale == 'Bark':
            # Convert Our formant measurements to bark
            f1_bark = [hz_to_bark(f1) for f1 in self.state['f1 means']]
            f2_bark = [hz_to_bark(f2) for f2 in self.state['f2 means']]
            user_data = pd.DataFrame(
                {
                    "F1 Bark": f1_bark,
                    "F2 Bark": f2_bark,
                }
            )
            # Set frequencies to bark
            freq1 = f1_bark
            freq2 = f2_bark
            # Set search data
            search_data = df[["F1 Bark", "F2 Bark"]].values

        else:  # Frequencies in Hz
            freq1 = self.state['f1 means']
            freq2 = self.state['f2 means']
            search_data = df[["F1", "F2"]].values

        # Draw points on the plot (dots, Vowels, or IPA symbols)
        user_vowels = []
        user_symbols = []

        for point in zip(freq1, freq2):
            # Find the closest vowel to our data in peterson barney in Euclidean space
            node, indexer = (self.closest_node(point, search_data))
            if vowel_marker == "Vowels" or vowel_marker == 'None':
                marker = f"{(df['Vowel'].loc[[indexer]]).values[0]}"
                user_vowels.append(marker)
            elif vowel_marker == "IPA Symbols":
                ipa_symbol_location = \
                    ipa_conversion_dataframe[ipa_conversion_dataframe["IPA"] == (df["IPA"].loc[[indexer]]).values[0]]
                try:
                    ipa_symbol = ipa_symbol_location["Symbol"].values.flat[0]
                    marker = ipa_symbol
                    user_symbols.append(marker)
                except:
                    ipa_symbol = '*'
                    marker = ipa_symbol
                    user_symbols.append(marker)

            y, x = point
            if vowel_marker =='None':
                ax_kwargs.text(x, y, f"$o$")
            else:
                ax_kwargs.text(x, y, f"${marker}$", fontsize=8)

        if len(user_vowels) > 0:
            user_data['Vowel'] = user_vowels
        elif len(user_symbols) > 0:
            user_data['Symbol'] = user_symbols

        plot_points = pd.DataFrame(list(zip(freq2, freq1)))
        if vowel_marker is not None:
            alpha_value = 0
            dot_colour = 'w'
        else:
            alpha_value = 100
            dot_colour = 'k'

        # plot invisible points or regular points if not a vowel or ipa symbol
        ax_kwargs.plot(plot_points, marker='o', c=dot_colour, alpha=alpha_value, linestyle="None")

        # Plot Ellipses
        if should_we_draw_ellipses[0].lower() == 'm' or should_we_draw_ellipses[0].lower() == 'p':
            if should_we_draw_ellipses[0].lower() == 'm':
                data_frame_we_use = user_data
            elif should_we_draw_ellipses[0].lower() == 'p':
                data_frame_we_use = df  # should rename to peterson_barney

            ells = []
            if vowel_marker == 'Vowels' or vowel_marker == 'None':
                for i, vowel in enumerate(vowels):
                    if scale == 'Bark':
                        y, x = data_frame_we_use['F1 Bark'][data_frame_we_use['Vowel'] == vowel], data_frame_we_use['F2 Bark'][data_frame_we_use['Vowel'] == vowel]
                    else:
                        y, x = data_frame_we_use['F1'][data_frame_we_use['Vowel'] == vowel], data_frame_we_use['F2'][data_frame_we_use['Vowel'] == vowel]
                    if len(y) >= 2:
                        self.confidence_ellipse(x, y, ax_kwargs, n_std=2, alpha=0.3, facecolor=colours[i],
                                                edgecolor='black', zorder=0)
                        ells.append(self.ellipse)

            elif vowel_marker == "IPA Symbols":
                for i, this_ipa_symbol in enumerate(ipa_symbols):
                    if scale == 'Bark':
                        print(data_frame_we_use.head())
                        y, x = data_frame_we_use['F1 Bark'][data_frame_we_use["Symbol"] == this_ipa_symbol], data_frame_we_use['F2 Bark'][data_frame_we_use["Symbol"] == this_ipa_symbol]
                    else:
                        y, x = data_frame_we_use['F1'][data_frame_we_use["Symbol"] == this_ipa_symbol], data_frame_we_use['F2'][data_frame_we_use["Symbol"] == this_ipa_symbol]
                    if len(y) >= 2:
                        self.confidence_ellipse(x, y, ax_kwargs, n_std=2, alpha=0.3, facecolor=colours[i],
                                                edgecolor='black', zorder=0)
                        ells.append(self.ellipse)

            if vowel_marker == "IPA Symbols":
                marker_column = ipa_symbols
                ax_kwargs.legend(ells, marker_column)
            elif vowel_marker == "Vowels" or vowel_marker == 'None':
                marker_column = vowels
                ax_kwargs.legend(ells, marker_column)

        # Determine axis limits
        cov = np.cov(freq2, freq1)
        scale_x = np.sqrt(cov[0, 0]) * 2
        xmin = scale_x - min(freq2)
        xmax = scale_x + max(freq2)
        scale_y = np.sqrt(cov[1, 1]) * 2
        ymin = scale_y - min(freq1)
        ymax = scale_y + max(freq1)

        # Make sure there is never a negative axis limit
        if xmin < 0:
            xmin = 0
        if ymin < 0:
            ymin = 0

        # Set plot axis limits
        plt.xlim(left=xmin)
        plt.xlim(right=xmax)
        plt.ylim(bottom=ymin)
        plt.ylim(top=ymax)

        # Set Plot Title
        ax_kwargs.set_title(f'F1 F2 Plot')

        # Set Plot Axis Labels
        if scale == 'Bark':
            ax_kwargs.set_xlabel("F2 [Bark]")
            ax_kwargs.set_ylabel("F1 [Bark]")
        else:
            ax_kwargs.set_xlabel("F2 [Hz]")
            ax_kwargs.set_ylabel("F1 [Hz]")

        fig.subplots_adjust(hspace=0.25)
        fig1 = plt.gcf()
        plt.show()
        fig1.savefig('f1f2.png', dpi=1000)
        self.f1f2plotwindow = F1F2PlotWindow()

        for i, result in enumerate(results):
            results[i][self]["F1F2 Plot"] = ["Figure Created"]
        return results

    def confidence_ellipse(self, x, y, ax, n_std=1, facecolor='none', **kwargs):
        """
        Create a plot of the covariance confidence ellipse of *x* and *y*.

        Parameters
        ----------
        x, y : array-like, shape (n, )
            Input data.

        ax : matplotlib.axes.Axes
            The axes object to draw the ellipse into.

        n_std : float
            The number of standard deviations to determine the ellipse's radiuses.

        Returns
        -------
        matplotlib.patches.Ellipse

        Other parameters
        ----------------
        kwargs : `~matplotlib.patches.Patch` properties
        """
        if x.size != y.size:
            raise ValueError("x and y must be the same size")

        cov = np.cov(x, y)
        pearson = cov[0, 1] / np.sqrt(cov[0, 0] * cov[1, 1])
        # Using a special case to obtain the eigenvalues of this
        # two-dimensionl dataset.
        ell_radius_x = np.sqrt(1 + pearson)
        ell_radius_y = np.sqrt(1 - pearson)
        ellipse = Ellipse((0, 0),
                          width=ell_radius_x * 2,
                          height=ell_radius_y * 2,
                          facecolor=facecolor,
                          **kwargs)
        self.g_ell_center = ellipse.get_center()
        self.g_ell_width = ell_radius_x * 2
        self.g_ell_height = ell_radius_y * 2
        self.angle = 45

        # Calculating the stdandard deviation of x from
        # the squareroot of the variance and multiplying
        # with the given number of standard deviations.
        scale_x = np.sqrt(cov[0, 0]) * n_std

        mean_x = np.mean(x)

        # calculating the stdandard deviation of y ...
        scale_y = np.sqrt(cov[1, 1]) * n_std
        mean_y = np.mean(y)

        transf = transforms.Affine2D() \
            .rotate_deg(45) \
            .scale(scale_x, scale_y) \
            .translate(mean_x, mean_y)

        ellipse.set_transform(transf + ax.transData)
        self.ellipse = ellipse
        return ax.add_patch(ellipse)


def hz_to_bark(hz):
    """
    This function converts Hz to Bark.
        Parameters
        ----------
        hz is the frequency in Hz

        Returns
        -------
        bark is the frequency in bark
    """
    bark = 7 * np.log(hz / 650 + np.sqrt(1 + (hz / 650) ** 2))
    return bark


def gather_data():
    """
    This function collects data from Peterson & Barney 1952 from Praat there is no input for the function.

        Returns
        -------
        peterson_barney a pandas dataframe that also includes bark measures using hz_to_bark function
    """

    peterson_barney = call("Create formant table (Peterson & Barney 1952)")
    peterson_barney = pd.read_csv(io.StringIO(call(peterson_barney, "List", True)), sep='\t', header=0).dropna()
    peterson_barney['F1 Bark'] = hz_to_bark(peterson_barney['F1'])
    peterson_barney['F2 Bark'] = hz_to_bark(peterson_barney['F2'])
    return peterson_barney
