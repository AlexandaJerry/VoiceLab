from Voicelab.pipeline.Node import Node
from parselmouth.praat import call
from Voicelab.toolkits.Voicelab.VoicelabNode import VoicelabNode


# MANIPULATE PITCH NODE
# WARIO pipeline node for manipulating the pitch of a voice.
# ARGUMENTS
# 'voice'   : sound file generated by parselmouth praat
# RETURNS


class MeasureLTASNode(VoicelabNode):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.args = {
            "Pitch corrected": False,
            "Bandwidth": 100,
            "Maximum frequency": 5000,
            "Shortest period (s)": 0.0001,
            "Longest period (s)": 0.02,
            "Maximum period factor": 1.3,
        }
        # process: WARIO hook called once for each voice file.

    def process(self):
        sound = self.args["voice"]
        try:
            f0min, f0max = self.pitch_bounds(sound)
            bandwidth = self.args["Bandwidth"]
            # todo grey these out when Pitch Corrected is False
            max_frequency = self.args["Maximum frequency"]
            shortest_period = self.args["Shortest period (s)"]
            longest_period = self.args["Longest period (s)"]
            max_period_factor = self.args["Maximum period factor"]

            if not self.args["Pitch corrected"]:
                ltas = call(sound, "To Ltas", 100)
            elif self.args["Pitch corrected"]:
                ltas = call(
                    sound,
                    "To Ltas (pitch-corrected)",
                    f0min,
                    f0max,
                    max_frequency,
                    bandwidth,
                    shortest_period,
                    longest_period,
                    max_period_factor,
                )

            mean_dB = call(ltas, "Get mean", 0, 0, "dB")
            slope_dB = call(ltas, "Get slope", 0, 1000, 1000, 4000, "dB")
            local_peak_height_dB = call(
                ltas, "Get local peak height", 1700, 4200, 2400, 3200, "dB"
            )
            standard_deviation_dB = call(ltas, "Get standard deviation", 0, 0, "dB")
            ltas_spectral_tilt = call(
                ltas, "Report spectral tilt", 100, 5000, "Linear", "Robust"
            )
            formula, slope, intercept = ltas_spectral_tilt.splitlines()
            slope_name, slope_value, slope_unit = slope.split()
            intercept_name, intercept_value, intercept_unit = intercept.split()
            return {
                "LTAS Mean (dB)": mean_dB,
                "LTAS slope (dB)": slope_dB,
                "LTAS local peak height (dB)": local_peak_height_dB,
                "LTAS standard deviation (dB)": standard_deviation_dB,
                "LTAS spectral tilt slope ({slope_unit})": slope_value,
                "LTAS spectral tilt intercept ({intercept_unit})": intercept_value,
            }
        except:
            return {
                "LTAS Mean (dB)": "LTAS failed",
                "LTAS slope (dB)": "LTAS failed",
                "LTAS local peak height (dB)": "LTAS failed",
                "LTAS standard deviation (dB)": "LTAS failed",
                "LTAS spectral tilt slope ": "LTAS failed",
                "LTAS spectral tilt intercept": "LTAS failed",
            }